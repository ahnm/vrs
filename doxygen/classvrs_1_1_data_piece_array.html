<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VRS: vrs::DataPieceArray&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="VRS-Icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VRS
   </div>
   <div id="projectbrief">A file format for sensor data.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevrs.html">vrs</a></li><li class="navelem"><a class="el" href="classvrs_1_1_data_piece_array.html">DataPieceArray</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classvrs_1_1_data_piece_array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vrs::DataPieceArray&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fixed size array of POD values.  
 <a href="classvrs_1_1_data_piece_array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_data_piece_array_8h_source.html">DataPieceArray.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8243ff4018ec94da036878f46ff2c117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a8243ff4018ec94da036878f46ff2c117">DataPieceArray</a> (const string &amp;label, size_t count)</td></tr>
<tr class="separator:a8243ff4018ec94da036878f46ff2c117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3443f8b12b3c97c3617bfaf441ec4d1b"><td class="memTemplParams" colspan="2">template&lt;size_t n&gt; </td></tr>
<tr class="memitem:a3443f8b12b3c97c3617bfaf441ec4d1b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a3443f8b12b3c97c3617bfaf441ec4d1b">DataPieceArray</a> (const string &amp;label, size_t count, const T(&amp;defaultValues)[n])</td></tr>
<tr class="separator:a3443f8b12b3c97c3617bfaf441ec4d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaebdf3b6afd337499a10418db439047"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#afaebdf3b6afd337499a10418db439047">DataPieceArray</a> (const MakerBundle &amp;bundle)</td></tr>
<tr class="separator:afaebdf3b6afd337499a10418db439047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9159931b59af79e704eb8693a36c7d92"><td class="memItemLeft" align="right" valign="top"><a id="a9159931b59af79e704eb8693a36c7d92"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a9159931b59af79e704eb8693a36c7d92">getArraySize</a> () const</td></tr>
<tr class="memdesc:a9159931b59af79e704eb8693a36c7d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the array. <br /></td></tr>
<tr class="separator:a9159931b59af79e704eb8693a36c7d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11573cd89a166055dea29f5332ce48b"><td class="memItemLeft" align="right" valign="top">const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#aa11573cd89a166055dea29f5332ce48b">getElementTypeName</a> () const override</td></tr>
<tr class="separator:aa11573cd89a166055dea29f5332ce48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17534d9301fbff404b52bbcd66f42ce"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#ac17534d9301fbff404b52bbcd66f42ce">getVariableSize</a> () const override</td></tr>
<tr class="separator:ac17534d9301fbff404b52bbcd66f42ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67759f1f13e0f27b6bc6abe7482916f7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a67759f1f13e0f27b6bc6abe7482916f7">collectVariableData</a> (int8_t *, size_t) const override</td></tr>
<tr class="separator:a67759f1f13e0f27b6bc6abe7482916f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226f9e5c8f4d5184dd1992c2bb09afb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a226f9e5c8f4d5184dd1992c2bb09afb6">get</a> (T *outValues, size_t count) const</td></tr>
<tr class="separator:a226f9e5c8f4d5184dd1992c2bb09afb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1cb7990b38a6e09817c892061401b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#afb1cb7990b38a6e09817c892061401b6">get</a> (T &amp;outValue, size_t index) const</td></tr>
<tr class="separator:afb1cb7990b38a6e09817c892061401b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce5d5e5ef53fa9ad865cdac825206d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#abce5d5e5ef53fa9ad865cdac825206d7">get</a> (vector&lt; T &gt; &amp;outValues) const</td></tr>
<tr class="separator:abce5d5e5ef53fa9ad865cdac825206d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8374829f180ca3f6af648dd21d2240e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a8374829f180ca3f6af648dd21d2240e3">set</a> (const T *values, size_t count)</td></tr>
<tr class="separator:a8374829f180ca3f6af648dd21d2240e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fecac93612fffefae079519fb2c7ae3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a2fecac93612fffefae079519fb2c7ae3">set</a> (const T &amp;value, size_t index)</td></tr>
<tr class="separator:a2fecac93612fffefae079519fb2c7ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb7a8376d65a3a105c3866c14614a7d"><td class="memTemplParams" colspan="2">template&lt;size_t n&gt; </td></tr>
<tr class="memitem:a6cb7a8376d65a3a105c3866c14614a7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a6cb7a8376d65a3a105c3866c14614a7d">set</a> (const T(&amp;arr)[n])</td></tr>
<tr class="separator:a6cb7a8376d65a3a105c3866c14614a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14c81e9725d9034681f3d6ceae04680"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#aa14c81e9725d9034681f3d6ceae04680">set</a> (const vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:aa14c81e9725d9034681f3d6ceae04680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce68e33bf8d606a27eef8e25986d30a"><td class="memItemLeft" align="right" valign="top">const vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a5ce68e33bf8d606a27eef8e25986d30a">getDefault</a> () const</td></tr>
<tr class="separator:a5ce68e33bf8d606a27eef8e25986d30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc90a131b4c622ece6b99e56401138f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#accc90a131b4c622ece6b99e56401138f">setDefault</a> (const T *defaultValues, size_t count)</td></tr>
<tr class="separator:accc90a131b4c622ece6b99e56401138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f2cb97c83f5511dd60a022947b351e"><td class="memTemplParams" colspan="2">template&lt;size_t n&gt; </td></tr>
<tr class="memitem:aa4f2cb97c83f5511dd60a022947b351e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#aa4f2cb97c83f5511dd60a022947b351e">setDefault</a> (const T(&amp;arr)[n])</td></tr>
<tr class="separator:aa4f2cb97c83f5511dd60a022947b351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8017e179c43570e7fce3226daaa672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#abf8017e179c43570e7fce3226daaa672">setDefault</a> (const vector&lt; T &gt; &amp;values)</td></tr>
<tr class="separator:abf8017e179c43570e7fce3226daaa672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce2a5e2ef469cb99cd0901025d1f63f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a3ce2a5e2ef469cb99cd0901025d1f63f">setProperty</a> (const string &amp;propertyName, T value)</td></tr>
<tr class="separator:a3ce2a5e2ef469cb99cd0901025d1f63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec920a56849a4344da11102a62cd3af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#adec920a56849a4344da11102a62cd3af">getProperty</a> (const string &amp;propertyName, T &amp;outValue) const</td></tr>
<tr class="separator:adec920a56849a4344da11102a62cd3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31898d8b0e62f684aefac459cba3c27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#ad31898d8b0e62f684aefac459cba3c27">setMin</a> (T min)</td></tr>
<tr class="separator:ad31898d8b0e62f684aefac459cba3c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a6ba6bae9e981adbfe7b58dc3e3a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#aa6a6ba6bae9e981adbfe7b58dc3e3a39">setMax</a> (T max)</td></tr>
<tr class="separator:aa6a6ba6bae9e981adbfe7b58dc3e3a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1503701aa1680a93c7a46d8038db766"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#aa1503701aa1680a93c7a46d8038db766">setRange</a> (T min, T max)</td></tr>
<tr class="separator:aa1503701aa1680a93c7a46d8038db766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5447497035e6350dea8c1264b0b739fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a5447497035e6350dea8c1264b0b739fe">getMin</a> (T &amp;outMin) const</td></tr>
<tr class="separator:a5447497035e6350dea8c1264b0b739fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d861c5436b634ee49817ef963e9c4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a97d861c5436b634ee49817ef963e9c4d">getMax</a> (T &amp;outMax) const</td></tr>
<tr class="separator:a97d861c5436b634ee49817ef963e9c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b472b671d4d5de13e84ea88e88005d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a6b472b671d4d5de13e84ea88e88005d5">isAvailable</a> () const override</td></tr>
<tr class="separator:a6b472b671d4d5de13e84ea88e88005d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c0b5dd551e05ae2aa0befa15ac2e96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a83c0b5dd551e05ae2aa0befa15ac2e96">print</a> (ostream &amp;out, const string &amp;indent) const override</td></tr>
<tr class="separator:a83c0b5dd551e05ae2aa0befa15ac2e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3c7736a6eeb3edc857c27aa87521bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a3c3c7736a6eeb3edc857c27aa87521bd">printCompact</a> (ostream &amp;out, const string &amp;indent) const override</td></tr>
<tr class="separator:a3c3c7736a6eeb3edc857c27aa87521bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e508084cf9746c1d49d49c76b86629"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#ad9e508084cf9746c1d49d49c76b86629">isSame</a> (const <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> *rhs) const override</td></tr>
<tr class="separator:ad9e508084cf9746c1d49d49c76b86629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b297fc55f61156bbd9e5fabc1261d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a41b297fc55f61156bbd9e5fabc1261d8">serialize</a> (JsonWrapper &amp;jsonWrapper, const <a class="el" href="structvrs_1_1_json_format_profile_spec.html">JsonFormatProfileSpec</a> &amp;profile) override</td></tr>
<tr class="separator:a41b297fc55f61156bbd9e5fabc1261d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76683a99948585a9bed47378806804e8"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvrs_1_1_data_piece_array.html#a76683a99948585a9bed47378806804e8">clone</a> () const override</td></tr>
<tr class="separator:a76683a99948585a9bed47378806804e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489f813aef6f4cf45d4ac6f18caec3f5"><td class="memTemplParams" colspan="2"><a id="a489f813aef6f4cf45d4ac6f18caec3f5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a489f813aef6f4cf45d4ac6f18caec3f5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DataPieceArray</b> (const <a class="el" href="structvrs_1_1_data_piece_1_1_maker_bundle.html">DataPiece::MakerBundle</a> &amp;bundle)</td></tr>
<tr class="separator:a489f813aef6f4cf45d4ac6f18caec3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3c9d1b102442624786e7cd491fa4245c"><td class="memItemLeft" align="right" valign="top"><a id="a3c9d1b102442624786e7cd491fa4245c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>stageFrom</b> (const <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> *) override</td></tr>
<tr class="separator:a3c9d1b102442624786e7cd491fa4245c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class vrs::DataPieceArray&lt; T &gt;</h3>

<p>Fixed size array of POD values. </p>
<p>Array of type T and fixed size. The array is stored in <a class="el" href="classvrs_1_1_data_layout.html" title="The DataLayout class describes the data stored inside a DataLayoutContentBlock.">DataLayout</a>'s fixed size buffer. The size of the array is defined at construction and may not change. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8243ff4018ec94da036878f46ff2c117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8243ff4018ec94da036878f46ff2c117">&#9670;&nbsp;</a></span>DataPieceArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::<a class="el" href="classvrs_1_1_data_piece_array.html">DataPieceArray</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Name for the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a>. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements in the fixes size-array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3443f8b12b3c97c3617bfaf441ec4d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3443f8b12b3c97c3617bfaf441ec4d1b">&#9670;&nbsp;</a></span>DataPieceArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::<a class="el" href="classvrs_1_1_data_piece_array.html">DataPieceArray</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>defaultValues</em>[n]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>Name for the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a>. </td></tr>
    <tr><td class="paramname">count</td><td>Number of elements in the fixes size-array. </td></tr>
    <tr><td class="paramname">defaultValues</td><td>Static array of default values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afaebdf3b6afd337499a10418db439047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaebdf3b6afd337499a10418db439047">&#9670;&nbsp;</a></span>DataPieceArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::<a class="el" href="classvrs_1_1_data_piece_array.html">DataPieceArray</a> </td>
          <td>(</td>
          <td class="paramtype">const MakerBundle &amp;&#160;</td>
          <td class="paramname"><em>bundle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bundle</td><td>Bundle to reconstruct a <a class="el" href="classvrs_1_1_data_piece_array.html" title="Fixed size array of POD values.">DataPieceArray</a> from disk. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a76683a99948585a9bed47378806804e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76683a99948585a9bed47378806804e8">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a>&gt; <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clone data piece. </p><dl class="section return"><dt>Returns</dt><dd>A clone of the data piece, with the same label, same type and same size. All the other data piece properties (default value and properties) are not cloned. </dd></dl>

</div>
</div>
<a id="a67759f1f13e0f27b6bc6abe7482916f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67759f1f13e0f27b6bc6abe7482916f7">&#9670;&nbsp;</a></span>collectVariableData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::collectVariableData </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy staged variable-size data to a specific location. [doesn't apply]. </p>

</div>
</div>
<a id="afb1cb7990b38a6e09817c892061401b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1cb7990b38a6e09817c892061401b6">&#9670;&nbsp;</a></span>get() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>outValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>get specific value in the array, by index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outValue</td><td>Reference to a value to set. </td></tr>
    <tr><td class="paramname">index</td><td>Value requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if an actual data value was read. False, if a default value was used, or T's default constructor. </dd></dl>

</div>
</div>
<a id="a226f9e5c8f4d5184dd1992c2bb09afb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226f9e5c8f4d5184dd1992c2bb09afb6">&#9670;&nbsp;</a></span>get() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>outValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>copy a given number of values to a given location. If not enough values are available, default values are written. If not enough default values are available, T's default constructor is used to fill-in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outValues</td><td>Pointer where to write the data. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the requested number of actual data values were copied, even if there were more values available than requested. Return false in all other cases. </dd></dl>

</div>
</div>
<a id="abce5d5e5ef53fa9ad865cdac825206d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce5d5e5ef53fa9ad865cdac825206d7">&#9670;&nbsp;</a></span>get() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>outValues</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get values or default values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outValues</td><td>Vector to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if actual data values were set, false if default values were read. </dd></dl>

</div>
</div>
<a id="a5ce68e33bf8d606a27eef8e25986d30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce68e33bf8d606a27eef8e25986d30a">&#9670;&nbsp;</a></span>getDefault()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;T&gt;&amp; <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::getDefault </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the array's default values. </p><dl class="section return"><dt>Returns</dt><dd>Default values. The vector is empty if no default values were set. </dd></dl>

</div>
</div>
<a id="aa11573cd89a166055dea29f5332ce48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11573cd89a166055dea29f5332ce48b">&#9670;&nbsp;</a></span>getElementTypeName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string&amp; <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::getElementTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the name of the element type &lt;T&gt;. </p>

</div>
</div>
<a id="a97d861c5436b634ee49817ef963e9c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d861c5436b634ee49817ef963e9c4d">&#9670;&nbsp;</a></span>getMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::getMax </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>outMax</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get maximum value for each element of the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outMax</td><td>Reference to set to the maximum valid value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is maximum value &amp; outMax was set. </dd></dl>

</div>
</div>
<a id="a5447497035e6350dea8c1264b0b739fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5447497035e6350dea8c1264b0b739fe">&#9670;&nbsp;</a></span>getMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::getMin </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>outMin</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get minimum value for each element of the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outMin</td><td>Reference to set to the minimum valid value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is minimum value &amp; outMin was set. </dd></dl>

</div>
</div>
<a id="adec920a56849a4344da11102a62cd3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec920a56849a4344da11102a62cd3af">&#9670;&nbsp;</a></span>getProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::getProperty </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>outValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a property </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyName</td><td>Name of the property. </td></tr>
    <tr><td class="paramname">outValue</td><td>Reference to a value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the property exists and outValue was set, false otherwise. </dd></dl>

</div>
</div>
<a id="ac17534d9301fbff404b52bbcd66f42ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17534d9301fbff404b52bbcd66f42ce">&#9670;&nbsp;</a></span>getVariableSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::getVariableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get variable-size. 0 here, since this is a fixed size <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a>. [doesn't apply]. </p>

</div>
</div>
<a id="a6b472b671d4d5de13e84ea88e88005d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b472b671d4d5de13e84ea88e88005d5">&#9670;&nbsp;</a></span>isAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::isAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell if a <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> value is available. </p><dl class="section return"><dt>Returns</dt><dd>True if the value is available, false if the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> could not be mapped. </dd></dl>

</div>
</div>
<a id="ad9e508084cf9746c1d49d49c76b86629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e508084cf9746c1d49d49c76b86629">&#9670;&nbsp;</a></span>isSame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::isSame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvrs_1_1_data_piece.html">DataPiece</a> *&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects for their equivalence. Note: the values are <b>not</b> compared, all the other properties are (type, name, tags, etc). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Other <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> objects are considered the same. </dd></dl>

</div>
</div>
<a id="a83c0b5dd551e05ae2aa0befa15ac2e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c0b5dd551e05ae2aa0befa15ac2e96">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::print </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> to the out stream, with many details, using indent text at the start of each line of output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Output stream to print to. </td></tr>
    <tr><td class="paramname">indent</td><td>Text to insert at the beginning of each output line, for indentation purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c3c7736a6eeb3edc857c27aa87521bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3c7736a6eeb3edc857c27aa87521bd">&#9670;&nbsp;</a></span>printCompact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::printCompact </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> to the out stream in compact form, using indent text at the start of each line of output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Output stream to print to. </td></tr>
    <tr><td class="paramname">indent</td><td>Text to insert at the beginning of each output line, for indentation purposes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41b297fc55f61156bbd9e5fabc1261d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b297fc55f61156bbd9e5fabc1261d8">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">JsonWrapper &amp;&#160;</td>
          <td class="paramname"><em>jsonWrapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvrs_1_1_json_format_profile_spec.html">JsonFormatProfileSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>profile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export the <a class="el" href="classvrs_1_1_data_piece.html" title="Abstract class representing a piece of information part of a DataLayout.">DataPiece</a> as json, using a specific profile. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonWrapper</td><td>Wrapper around a json type (to isolate any 3rd party library dependency). </td></tr>
    <tr><td class="paramname">profile</td><td>Profile describing what information needs to be exported as json. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fecac93612fffefae079519fb2c7ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fecac93612fffefae079519fb2c7ae3">&#9670;&nbsp;</a></span>set() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set one value of the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Reference to the value to write. </td></tr>
    <tr><td class="paramname">index</td><td>Index of the array element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the array was large enough, and the value could be written. Note: does not touch the other array values. </dd></dl>

</div>
</div>
<a id="a8374829f180ca3f6af648dd21d2240e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8374829f180ca3f6af648dd21d2240e3">&#9670;&nbsp;</a></span>set() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set array values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>pointer to values to write. </td></tr>
    <tr><td class="paramname">count</td><td>Number of values to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if values were written. Note: if more values are given than the size of the array, fewer values will be written, but the method still returns true. If not enough values are given to set the whole array, T's default constructor is used to init the remaining values. </dd></dl>

</div>
</div>
<a id="a6cb7a8376d65a3a105c3866c14614a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb7a8376d65a3a105c3866c14614a7d">&#9670;&nbsp;</a></span>set() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>arr</em>[n]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set array values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>C-style array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if values were written. Note: if more values are given than the size of the array, fewer values will be written, but the method still returns true. If not enough values are given to set the whole array, T's default constructor is used to init the remaining values. </dd></dl>

</div>
</div>
<a id="aa14c81e9725d9034681f3d6ceae04680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14c81e9725d9034681f3d6ceae04680">&#9670;&nbsp;</a></span>set() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set array values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Vector of values to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if values were written. Note: if more values are given than the size of the array, fewer values will be written, but the method still returns true. If not enough values are given to set the whole array, T's default constructor is used to init the remaining values. </dd></dl>

</div>
</div>
<a id="accc90a131b4c622ece6b99e56401138f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc90a131b4c622ece6b99e56401138f">&#9670;&nbsp;</a></span>setDefault() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::setDefault </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>defaultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the array's default values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValues</td><td>Pointer to the first default value. </td></tr>
    <tr><td class="paramname">count</td><td>Number of default values to use. Note: if fewer default values are passed that the size of the array, T's default constructor is used to have the exact count of default values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4f2cb97c83f5511dd60a022947b351e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f2cb97c83f5511dd60a022947b351e">&#9670;&nbsp;</a></span>setDefault() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::setDefault </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>arr</em>[n]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the array's default values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>C-style array ot default values. Note: if fewer default values are passed that the size of the array, T's default constructor is used to have the exact count of default values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf8017e179c43570e7fce3226daaa672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8017e179c43570e7fce3226daaa672">&#9670;&nbsp;</a></span>setDefault() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::setDefault </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the array's default values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValues</td><td>Vector of default values. Note: if fewer default values are passed that the size of the array, T's default constructor is used to have the exact count of default values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6a6ba6bae9e981adbfe7b58dc3e3a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a6ba6bae9e981adbfe7b58dc3e3a39">&#9670;&nbsp;</a></span>setMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::setMax </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximum valid value for each element of the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>Maximum valid value. Note: max checking is a sanity check operation only. Nothing prevents users of the API to set the values of the array any way they want. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad31898d8b0e62f684aefac459cba3c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31898d8b0e62f684aefac459cba3c27">&#9670;&nbsp;</a></span>setMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::setMin </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the minimum valid value for each element of the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum valid value. Note: min checking is a sanity check operation only. Nothing prevents users of the API to set the values of the array any way they want. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ce2a5e2ef469cb99cd0901025d1f63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce2a5e2ef469cb99cd0901025d1f63f">&#9670;&nbsp;</a></span>setProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::setProperty </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a property. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyName</td><td>Name of the property. </td></tr>
    <tr><td class="paramname">value</td><td>Value of the property. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1503701aa1680a93c7a46d8038db766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1503701aa1680a93c7a46d8038db766">&#9670;&nbsp;</a></span>setRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvrs_1_1_data_piece_array.html">vrs::DataPieceArray</a>&lt; T &gt;::setRange </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the min &amp; max valid values for each element of the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum valid value. </td></tr>
    <tr><td class="paramname">max</td><td>Maximum valid value. Note: min/max checking is a sanity check operation only. Nothing prevents users of the API to set the values of the array any way they want. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>vrs/<a class="el" href="_data_layout_8h_source.html">DataLayout.h</a></li>
<li>vrs/<a class="el" href="_data_piece_array_8h_source.html">DataPieceArray.h</a></li>
<li>vrs/DataLayout.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
